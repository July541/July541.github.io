<!DOCTYPE html>
<html  lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="viewport" content="width=device-width, initial-scale=1" />

      <title>1.2. 拖慢程序运行速度的原因</title>
    
          <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/theme.css " type="text/css" />
          <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/css/s4defs-roles.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/css/iframe.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/css/admonitions.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/css/s4defs-roles.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/css/iframe.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/css/admonitions.css" type="text/css" />
      
      <!-- sphinx script_files -->
        <script src="../../../_static/documentation_options.js?v=d45e8c67"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../_static/copybutton.js?v=f281be69"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../../../_static/theme-vendors.js"></script> -->
      <script src="../../../_static/theme.js" defer></script>
    
  <link rel="index" title="Index" href="../../../genindex.html" />
  <link rel="search" title="Search" href="../../../search.html" />
  <link rel="next" title="Glossary" href="../../glossary.html" />
  <link rel="prev" title="1.1. 如何使用本书" href="how_to_use.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../../../contents.html" class="home-link">
    
      <span class="site-name">Haskell Optimization Handbook</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">

  
    <div class="nav-item">
      <a href="../../../contents.html#haskell-optimization-handbook"
         class="nav-link ">
         Table of Contents
      </a>
    </div>
  
    <div class="nav-item">
      <a href="index.html#id1"
         class="nav-link  router-link-active">
         前期准备
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../../../contents.html#indices-and-tables"
         class="nav-link ">
         indices and tables
      </a>
    </div>
  



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            

  
    <div class="nav-item">
      <a href="../../../contents.html#haskell-optimization-handbook"
         class="nav-link ">
         Table of Contents
      </a>
    </div>
  
    <div class="nav-item">
      <a href="index.html#id1"
         class="nav-link  router-link-active">
         前期准备
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../../../contents.html#indices-and-tables"
         class="nav-link ">
         indices and tables
      </a>
    </div>
  



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">Quick search</span>
    <div class="searchformwrapper">
      <form class="search" action="../../../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="Search" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../../contents.html#haskell-optimization-handbook">Table of Contents</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../../Preliminaries/index.html" class="reference internal ">Preliminaries</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../../Measurement_Observation/index.html" class="reference internal ">Measurement, Profiling, and Observation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../../Optimizations/index.html" class="reference internal ">Optimizations</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../../Case_Studies/index.html" class="reference internal ">Case Studies</a>
            

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="index.html#id1">前期准备</a></span>
      </p>
      <ul class="current">
        
          <li class="toctree-l1 ">
            
              <a href="how_to_use.html" class="reference internal ">如何使用本书</a>
            

            
          </li>

        
          <li class="toctree-l1 current">
            
              <a href="#" class="reference internal current">拖慢程序运行速度的原因</a>
            

            
              <ul>
                
                  <li class="toctree-l2"><a href="#canonical-inlining" class="reference internal">内联</a></li>
                
                  <li class="toctree-l2"><a href="#canonical-fusion" class="reference internal">融合</a></li>
                
                  <li class="toctree-l2"><a href="#pointer-chasing" class="reference internal">过度的 Pointer Chasing</a></li>
                
                  <li class="toctree-l2"><a href="#canonical-closure-alloc" class="reference internal">过度的闭包分配</a></li>
                
                  <li class="toctree-l2"><a href="#canonical-domain-modeling" class="reference internal">糟糕的领域建模</a></li>
                
                  <li class="toctree-l2"><a href="#references" class="reference internal">References</a></li>
                
              </ul>
            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../../contents.html#indices-and-tables">indices and tables</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../../glossary.html" class="reference internal ">Glossary</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../../../contents.html">Docs</a> &raquo;</li>
    
      <li><a href="index.html"><span class="section-number">1. </span>前期准备</a> &raquo;</li>
    
    <li><span class="section-number">1.2. </span>拖慢程序运行速度的原因</li>
  </ul>
  

  <ul class="page-nav">
  <li class="prev">
    <a href="how_to_use.html"
       title="previous chapter">← <span class="section-number">1.1. </span>如何使用本书</a>
  </li>
  <li class="next">
    <a href="../../glossary.html"
       title="next chapter">Glossary →</a>
  </li>
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="sec-lethargy">
<span id="id1"></span><h1><span class="section-number">1.2. </span>拖慢程序运行速度的原因<a class="headerlink" href="#sec-lethargy" title="Link to this heading">¶</a></h1>
<p>本章会展示一些特定条件下导致 Haskell 代码运行变慢的程序，这些程序具有很典型的特征，因此也被称为样板(canonical)程序。在阅读本章后，读者应该对 Haskell 程序运行变慢的原因有基本的了解。本章提到的这些程序只是一个简单的介绍，对于具体的细节将会在书中的后续部分进行详细解释。</p>
<section id="canonical-inlining">
<span id="id2"></span><h2><span class="section-number">1.2.1. </span>内联<a class="headerlink" href="#canonical-inlining" title="Link to this heading">¶</a></h2>
<section id="id3">
<h3><span class="section-number">1.2.1.1. </span>什么是内联<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h3>
<p>内联 <a class="footnote-reference brackets" href="#id30" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> 是一个几乎所有编译器都会使用的简单的优化技巧。内联核心的想法是将函数 <code class="docutils literal notranslate"><span class="pre">f</span></code> 的调用点展开为 <code class="docutils literal notranslate"><span class="pre">f</span></code> 本身的实现。例如：</p>
<div class="literal-block-wrapper docutils container" id="id36">
<div class="code-block-caption"><span class="caption-text">未执行内联</span><a class="headerlink" href="#id36" title="Link to this code">¶</a></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span>
<span class="c1">--- somewhere else</span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span>
</pre></div>
</div>
</div>
<p>上述代码首先定义了一个函数 <code class="docutils literal notranslate"><span class="pre">f</span></code>，随后函数 <code class="docutils literal notranslate"><span class="pre">f</span></code> 应用于 <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span> <span class="pre">-</span> <span class="pre">c</span></code>。内联机制会将 <code class="docutils literal notranslate"><span class="pre">f</span></code> 在调用点进行展开，<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span></code> 会被替换为 <code class="docutils literal notranslate"><span class="pre">f</span></code> 本身的实现。</p>
<div class="literal-block-wrapper docutils container" id="id37">
<div class="code-block-caption"><span class="caption-text">执行内联</span><a class="headerlink" href="#id37" title="Link to this code">¶</a></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span>
<span class="c1">-- somewhere else</span>
<span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span>
</pre></div>
</div>
</div>
<p>可以看到 <code class="docutils literal notranslate"><span class="pre">f</span></code> 的调用被替换为 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">3</span></code>，其中 <span class="math notranslate nohighlight">\(x \mapsto (a + b)\)</span>。</p>
</section>
<section id="id5">
<h3><span class="section-number">1.2.1.2. </span>为什么要进行内联<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h3>
<p>内联也被称为“所有优化的起点”。首先，内联减少了函数调用的开销，这对频繁调用的函数有很大益处。其次，通过将函数的调用点替换为函数本身的实现，编译器在后续可以对内联之后的结果做进一步的优化来生成运行速度更快的代码。这种性能上的优化与其说是计算机科学的应用，比如说是艺术的展现，任何微小的变化都可能会产生出意想不到的效果。</p>
</section>
<section id="id6">
<h3><span class="section-number">1.2.1.3. </span>什么场景下内联会影响性能<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h3>
<p>内联操作本身并不会降低运行速度，而缺乏内联会影响后续可能的优化操作的执行，从而导致运行速度降低。然而，这并不意味着我们需要永远让 GHC 执行内联操作或手动强制内联，相反，我们有时可以通过禁止内联来实现性能优势。在后续的 <a class="reference internal" href="../../Optimizations/Code_Changes/inlining.html#inlining-chapter"><span class="std std-ref">内联</span></a> 一章中会对内联的性能效果做出分析，并展示 GHC 如何执行内联。</p>
</section>
</section>
<section id="canonical-fusion">
<span id="id7"></span><h2><span class="section-number">1.2.2. </span>融合<a class="headerlink" href="#canonical-fusion" title="Link to this heading">¶</a></h2>
<section id="id8">
<h3><span class="section-number">1.2.2.1. </span>什么是融合<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h3>
<p>融合 <a class="footnote-reference brackets" href="#id31" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id32" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> (Fusion，也被称为 Deforestation，这里参考 Andy  Gill 论文中的例子，感谢 Andy Gill 的工作！) 是一种消除函数调用之间的中间状态和临时数据结构的优化技术。由于 Haskell 惯用的函数组合的写法，融合成为了一种关键的优化方法。例如：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">all</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">all</span></code> 通过 <code class="docutils literal notranslate"><span class="pre">map</span></code> 函数将 <code class="docutils literal notranslate"><span class="pre">p</span></code> 应用于 <code class="docutils literal notranslate"><span class="pre">xs</span></code> 的每个元素，在这个过程中产生了一个 bool 类型的 list。产生的 list 只是短暂地存在于计算的过程中，随后被应用于 <code class="docutils literal notranslate"><span class="pre">and</span></code> 产生最后的 bool 类型的结果。不幸的是，使用这个临时的 list 是十分昂贵的，需要在堆上为 list 的每个元素都申请内存、分配一个 <code class="docutils literal notranslate"><span class="pre">Cons</span></code>，并用 thunk 填充，然后赋一个具体的值，随后被 <code class="docutils literal notranslate"><span class="pre">and</span></code> 访问，最后再释放。完整的流程需要需要额外的 CPU 周期和垃圾回收机制。</p>
<p>融合可以将 <code class="docutils literal notranslate"><span class="pre">all</span></code> 这类函数转化为不需要中间 list 的形式。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">all&#39;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">xs</span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="kt">[]</span><span class="w">     </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">xs</span>
</pre></div>
</div>
<p>这个版本的 <code class="docutils literal notranslate"><span class="pre">all</span></code> <em>不会</em> 产生任何的中间 list，在对 <code class="docutils literal notranslate"><span class="pre">xs</span></code> 的每一步计算都会产生一个 bool 值，这个值会被直接应用到 <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>，产生一个由 <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> 连接到函数调用链（事实上这个调用链就是 <code class="docutils literal notranslate"><span class="pre">and</span></code> 函数的实现方式）。因为这一版本的实现成功地消除了中间状态的 list，也就是 <code class="docutils literal notranslate"><span class="pre">and</span></code> 和 <code class="docutils literal notranslate"><span class="pre">map</span></code> <em>融合</em> 了。</p>
</section>
<section id="id11">
<h3><span class="section-number">1.2.2.2. </span>为什么需要融合<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h3>
<p>正如 Andy Gill 所说：</p>
<blockquote>
<div><p>We want to eat our cake and have it too. That is, we would like to write
programs in the style of <code class="docutils literal notranslate"><span class="pre">all</span></code> but have the compiler automatically
transform this into the more efficient version <code class="docutils literal notranslate"><span class="pre">all'</span></code>.</p>
</div></blockquote>
<p>大致翻译如下：</p>
<blockquote>
<div><p>鱼与熊掌，不可兼得。我们既想编写 <code class="docutils literal notranslate"><span class="pre">all</span></code> 风格的代码，也希望编译器可以自动将我们的代码转化为更高效的 <code class="docutils literal notranslate"><span class="pre">all'</span></code> 形式。</p>
</div></blockquote>
</section>
<section id="id12">
<h3><span class="section-number">1.2.2.3. </span>什么场景下融合会影响性能<a class="headerlink" href="#id12" title="Link to this heading">¶</a></h3>
<p>与内联类似，融合本身并不会降低系统的运行速度，反而缺乏融合会造成系统运行速度降低。这是由于系统会为那些本可以融合却并没有这样做的函数分配额外的内存，从而导致性能降低。</p>
<p>对融合来说最困难的地方莫过于发现融合是使你性能降低的根本原因和告诉 GNHC 如何融合你的代码。<a class="reference internal" href="../../Optimizations/Code_Changes/fusion_and_rules.html#fusion-rules-chapter"><span class="std std-ref">融合</span></a> 会展示如何识别你的代码是否需要融合，同时也会介绍如何使 GHC 进行融合。</p>
</section>
</section>
<section id="pointer-chasing">
<span id="canonical-pointer-chasing"></span><h2><span class="section-number">1.2.3. </span>过度的 Pointer Chasing<a class="headerlink" href="#pointer-chasing" title="Link to this heading">¶</a></h2>
<section id="id13">
<h3><span class="section-number">1.2.3.1. </span>什么是过度的 Pointer Chasing<a class="headerlink" href="#id13" title="Link to this heading">¶</a></h3>
<p>过度的 Pointer Chasing 是一种多余的计算形式；我们的程序在计算结果时做了比实际需要更多的工作。每当我们的程序解引用指针以检索值而不是直接引用值本身时，就会发生这种情况，这导致访问过程创建了一个不必要的中间过程。</p>
<p>在 Haskell 程序中，这种情况最常发生在我们编写程序时没有考虑它们的内存表示方式，并且尤其涉及到惰性计算时这种情况更稳严重。大部分这些情况都是众所周知的，并且在社区中已经存在一段时间了。</p>
</section>
<section id="id14">
<h3><span class="section-number">1.2.3.2. </span>过度的 Pointer Chasing 为什么会影响性能<a class="headerlink" href="#id14" title="Link to this heading">¶</a></h3>
<p>经典例子是 fold 的惰性求值引起的内存泄漏，例如 <a class="footnote-reference brackets" href="#id33" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>：</p>
<div class="literal-block-wrapper docutils container" id="id38">
<div class="code-block-caption"><span class="caption-text">惰性的 foldl</span><a class="headerlink" href="#id38" title="Link to this code">¶</a></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mean</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Double</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span>
<span class="nf">mean</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fromIntegral</span><span class="w"> </span><span class="n">ln</span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w">        </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">        </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id39">
<div class="code-block-caption"><span class="caption-text">立即求值的 foldl’</span><a class="headerlink" href="#id39" title="Link to this code">¶</a></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mean&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Double</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span>
<span class="nf">mean&#39;</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fromIntegral</span><span class="w"> </span><span class="n">ln</span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w">        </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl&#39;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">        </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mean</span></code> 和 <code class="docutils literal notranslate"><span class="pre">mean'</span></code> 展示了两种常见的内存泄露形式。<code class="docutils literal notranslate"><span class="pre">mean</span></code> 使用惰性的 <code class="docutils literal notranslate"><span class="pre">foldl</span></code> 导致大量内存堆积； <code class="docutils literal notranslate"><span class="pre">mean'</span></code> 的问题在于，虽然 <code class="docutils literal notranslate"><span class="pre">foldl'</span></code> 是严格形式，但是 <code class="docutils literal notranslate"><span class="pre">foldl'</span></code> 只会将表达式求值到 <a class="reference internal" href="../../glossary.html#term-WHNF"><span class="xref std std-term">WHNF</span></a>。在本例中 <code class="docutils literal notranslate"><span class="pre">foldl'</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">step</span></code> 只会将 tuple 求值到它的 constructor，即 <code class="docutils literal notranslate"><span class="pre">(,)</span></code>，而不是 <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">+</span> <span class="pre">a</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">ln</span> <span class="pre">+</span> <span class="pre">1</span></code>。由于惰性计算的原因，这些 <code class="docutils literal notranslate"><span class="pre">(,)</span></code> 会被存储在堆上，因此我们必须通过这些指向 <code class="docutils literal notranslate"><span class="pre">(,)</span></code> 的指针来进行计算。</p>
<p>另一种常见的过度 Pointer Chasing 的形式是在 data constructor 中过度使用惰性字段，特别是当该字段永远都会被求值时，使用惰性并没有任何优势，甚至会影响程序的性能。考虑如下例子，<code class="docutils literal notranslate"><span class="pre">step</span></code> 不再通过 tuple 计算，而是使用自定义类型：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Step</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Step</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="kt">Double</span>
<span class="o">...</span>

<span class="c1">-- mean rewritten with Step instead of (,)</span>
<span class="nf">mean&#39;&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Double</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span>
<span class="nf">mean&#39;&#39;</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fromIntegral</span><span class="w"> </span><span class="n">ln</span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="kt">Step</span><span class="w"> </span><span class="n">s</span><span class="w">  </span><span class="n">ln</span><span class="p">)</span><span class="w">       </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl&#39;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">        </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="kt">Step</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Step</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ln</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>与 <code class="docutils literal notranslate"><span class="pre">mean'</span></code> 堆积了大量的 <code class="docutils literal notranslate"><span class="pre">(,)</span></code> 类似，由于 <code class="docutils literal notranslate"><span class="pre">Step</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Double</span></code> 是惰性的，<code class="docutils literal notranslate"><span class="pre">mean''</span></code> 同样也有大量的 <code class="docutils literal notranslate"><span class="pre">(s</span> <span class="pre">+</span> <span class="pre">a)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">(ln</span> <span class="pre">+</span> <span class="pre">1)</span></code> 的 thunk。但是在我们的目标：计算平均值中，我们并没有从这种惰性中获得任何好处，因为我们的程序不需要惰性求值。因此在这种场景下应该立即对 <code class="docutils literal notranslate"><span class="pre">Step</span></code> 进行求值以消除中间的计算结果，避免不必要的内存分配。</p>
<p>还有一种场景是，在 data constructor 可以使用 <a class="reference internal" href="../../glossary.html#term-Unboxed"><span class="xref std std-term">Unboxed</span></a> 的字段时反而使用了 <a class="reference internal" href="../../glossary.html#term-Boxed"><span class="xref std std-term">Boxed</span></a> 的版本。考虑如下例子，<code class="docutils literal notranslate"><span class="pre">Counter</span></code> 是对某个特定领域 Int 的包装：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Counter</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Counter</span><span class="w"> </span><span class="kt">Int</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>通常情况下，使用 <code class="docutils literal notranslate"><span class="pre">-O2</span></code> 编译选项编译时，GHC 会识别这种场景并对 <code class="docutils literal notranslate"><span class="pre">Counter</span></code> 进行优化。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Int</span></code> 是 <code class="docutils literal notranslate"><span class="pre">Counter</span></code> 中的一个 <a class="reference internal" href="../../glossary.html#term-Boxed"><span class="xref std std-term">Boxed</span></a> 且 <a class="reference internal" href="../../glossary.html#term-Lifted"><span class="xref std std-term">Lifted</span></a> 的类型。这意味着每个 <code class="docutils literal notranslate"><span class="pre">Counter</span></code> 都会储存一个指针，指向一个保存在堆上的 <code class="docutils literal notranslate"><span class="pre">Int</span></code> 对象，而不是 <code class="docutils literal notranslate"><span class="pre">Int</span></code> 本身的值。我们可以使用 <a class="reference external" href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/exts/pragmas.html?highlight=unpack#unpack-pragma">unpack</a> 和 bang pattern 来告诉 GHC 移除堆中的间接引用。</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Counter</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Counter</span><span class="w"> </span><span class="cm">{-# UNPACK -#} !Int</span>
</pre></div>
</div>
<p>上面的代码告诉 GHC 将 <code class="docutils literal notranslate"><span class="pre">Int</span></code> 的值直接储存在 <code class="docutils literal notranslate"><span class="pre">Counter</span></code> 中，而不是储存一个指向 <code class="docutils literal notranslate"><span class="pre">Int</span></code> 的指针。在 <a class="reference internal" href="../../Optimizations/Code_Changes/unboxing.html#unboxing"><span class="std std-ref">Unboxing</span></a> 一章中将会对这种方法做进一步的介绍。</p>
</section>
</section>
<section id="canonical-closure-alloc">
<span id="id16"></span><h2><span class="section-number">1.2.4. </span>过度的闭包分配<a class="headerlink" href="#canonical-closure-alloc" title="Link to this heading">¶</a></h2>
<section id="id17">
<h3><span class="section-number">1.2.4.1. </span>什么是过度的闭包分配<a class="headerlink" href="#id17" title="Link to this heading">¶</a></h3>
<p>过度的闭包分配（Excessive closure allocation）是另一种多余的计算和内存分配的形式；这意味着我们的程序在计算结果时进行了更多的内存分配和更多的计算。过度的闭包分配的形成有以下两种原因：首先是由于 GHC 通过 <a class="reference internal" href="../../glossary.html#term-Let-Floating"><span class="xref std std-term">Let Floating</span></a> 可以得到很好的优化结果，因此大多数 Haskell 用户从来没有意识到有这个问题存在（这也侧面说明了 GHC 的质量很高=。=）；另一方面，为了观察到过度的闭包分配，程序员必须大量跟踪程序在函数（functions）、模块（modules）和包（packages）中的内存分配，在大多数 Haskell 开发场景中是不会这样做的。</p>
<p>我们将给出一些示例，GHC 可以轻松找到这些例子存在的问题并给出优化。<a class="reference internal" href="../../Case_Studies/sbv_572.html#sbv572"><span class="std std-ref">Impact of seq Removal on SBV’s cache</span></a> 会展示在一个广泛应用的库中存在的大量内存申请的例子。</p>
<div class="admonition-todo admonition" id="id19">
<p class="admonition-title">Todo</p>
<p>Not yet written, see <a class="reference external" href="https://github.com/input-output-hk/hs-opt-handbook.github.io/issues/18">#18</a></p>
</div>
<p>虽然 GHC 对这些场景的优化表现很好，但熟悉这些代码的变换原因是有益的；这会使得用户在阅读或编写 Haskell 代码时开始以内存分配为基础进行思考，并逐渐掌握如何在 GHC 无法进行优化时手动执行这些优化。</p>
</section>
<section id="id20">
<h3><span class="section-number">1.2.4.2. </span>过度的闭包分配为什么会影响性能<a class="headerlink" href="#id20" title="Link to this heading">¶</a></h3>
<p>考虑如下例子 <a class="footnote-reference brackets" href="#id34" id="id21" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="kr">in</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="n">zs</span><span class="w"> </span><span class="kr">of</span>
<span class="w">        </span><span class="kt">[]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span>
<span class="w">        </span><span class="kr">_</span><span class="w">  </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
<p>这是 <code class="docutils literal notranslate"><span class="pre">Let</span> <span class="pre">Floating</span> <span class="pre">inwards</span></code> 一个例子，注意到 <code class="docutils literal notranslate"><span class="pre">x</span></code> 只在 case 的一个分支中用到，另一个分支则不需要。因此 GHC 可以将 <code class="docutils literal notranslate"><span class="pre">x</span></code> 移动到第一个分支中（floating inward）：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="n">zs</span><span class="w"> </span><span class="kr">of</span>
<span class="w">     </span><span class="kt">[]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">           </span><span class="kr">in</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span>
<span class="w">     </span><span class="kr">_</span><span class="w">  </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
<p>在这种场景中，<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">...</span></code> 从必定执行变成了在特定条件下执行（译者注：这里的执行指的是分配一个 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的 thunk），取决于 <code class="docutils literal notranslate"><span class="pre">tail</span> <span class="pre">zs</span></code> 的结果。因此，第二种写法虽然在语义上与第一种相同，但是却更高效，因为第二种写法可以在某些场景下避免 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">...</span></code>，从而避免额外的堆分配。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Let Floating 可能会改变 <a class="reference internal" href="../../glossary.html#term-Thunk"><span class="xref std std-term">Thunk</span></a> 的大小。</p>
</div>
<p>考虑 <span id="id22">Peyton Jones and Santos [<a class="reference internal" href="../../../contents.html#id5" title="Simon Peyton Jones and Andre Santos. A transformation-based optimiser for haskell. Science of Computer Programming, October 1997. URL: https://www.microsoft.com/en-us/research/publication/a-transformation-based-optimiser-for-haskell/.">2</a>]</span> 7.1 节中的一个例子：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="w">     </span><span class="c1">-- v 和 w 是 x 中的自由变量（free variables）</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="n">x</span><span class="o">...</span><span class="n">x</span><span class="w">  </span><span class="c1">-- y 使用到了 x</span>
<span class="kr">in</span><span class="w"> </span><span class="kt">B</span><span class="w">              </span><span class="c1">-- B 没有使用 x</span>
</pre></div>
</div>
<p>对 <code class="docutils literal notranslate"><span class="pre">x</span></code> 进行移动：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="c1">-- v 和 w 变成了 y 的自由变量</span>
<span class="w">        </span><span class="kr">in</span><span class="w"> </span><span class="o">...</span><span class="n">x</span><span class="o">...</span><span class="n">x</span>
<span class="kr">in</span><span class="w"> </span><span class="kt">B</span>
</pre></div>
</div>
<p>现在 <code class="docutils literal notranslate"><span class="pre">v</span></code> 和 <code class="docutils literal notranslate"><span class="pre">w</span></code> 变成了 <code class="docutils literal notranslate"><span class="pre">y</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的自由变量。<code class="docutils literal notranslate"><span class="pre">x</span></code> 是 <code class="docutils literal notranslate"><span class="pre">y</span></code> 中的变量（会被内联）。因此如果 <code class="docutils literal notranslate"><span class="pre">v</span></code> 和 <code class="docutils literal notranslate"><span class="pre">w</span></code> 是自由变量，那么 <code class="docutils literal notranslate"><span class="pre">y</span></code> 的 thunk 大小将会保持不变。然而如果 <code class="docutils literal notranslate"><span class="pre">v</span></code> 和 <code class="docutils literal notranslate"><span class="pre">w</span></code> 是新的自由变量，那么 <code class="docutils literal notranslate"><span class="pre">y</span></code> 的大小会进行对应的增加。</p>
<p><code class="docutils literal notranslate"><span class="pre">Let</span> <span class="pre">bindings</span></code> 也可以向外移动（outwards）。在 <code class="docutils literal notranslate"><span class="pre">case</span></code> 表达式附近移动 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">bindings</span></code> 有不止一种方法，这里会介绍一种非常有效的移动方法，叫做 <a class="reference internal" href="../../glossary.html#term-Full-Laziness-transformation"><span class="xref std std-term">Full Laziness transformation</span></a>。<span class="incremental">Full Laziness transformation</span> 会将 <code class="docutils literal notranslate"><span class="pre">bindings</span></code> 完全从 lambda 表达式中抽离出来。</p>
<p>考虑如下代码：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">xs</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span>
<span class="w">             </span><span class="n">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">xs</span><span class="w">  </span><span class="c1">-- 计算 n</span>
<span class="w">                       </span><span class="kr">in</span><span class="w"> </span><span class="o">...</span><span class="n">g</span><span class="o">...</span><span class="n">n</span><span class="w">        </span><span class="c1">-- 使用 n 而不是 xs</span>
<span class="w">           </span><span class="kr">in</span><span class="w"> </span><span class="o">...</span><span class="n">g</span><span class="o">...</span>
</pre></div>
</div>
<p>我们有一个外部函数 <code class="docutils literal notranslate"><span class="pre">f</span></code>，它定义了一个紧密的内部循环 <code class="docutils literal notranslate"><span class="pre">g</span></code>。请注意，<code class="docutils literal notranslate"><span class="pre">g</span></code> 的每次递归调用都会为 <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">xs</span></code> 分配空间，并进行计算，因为 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">...</span></code> 是在 <code class="docutils literal notranslate"><span class="pre">g</span></code> 的函数体内部，而且 <code class="docutils literal notranslate"><span class="pre">n</span></code> 也在 <code class="docutils literal notranslate"><span class="pre">g</span></code> 中使用。但这显然是浪费的，因为在 <code class="docutils literal notranslate"><span class="pre">g</span></code> 的函数体内 <code class="docutils literal notranslate"><span class="pre">xs</span></code> 并没有改变，所以我们只需要计算一次 <code class="docutils literal notranslate"><span class="pre">n</span></code> 就足够了。幸运的是，<code class="docutils literal notranslate"><span class="pre">g</span></code> 除了计算 <code class="docutils literal notranslate"><span class="pre">n</span></code> 之外不使用 <code class="docutils literal notranslate"><span class="pre">xs</span></code>，所以 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">...</span></code> 可以从 <code class="docutils literal notranslate"><span class="pre">g</span></code> 中提出来：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">xs</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">xs</span><span class="w">          </span><span class="c1">-- n 只计算一次</span>
<span class="w">           </span><span class="kr">in</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">...</span><span class="n">g</span><span class="o">...</span><span class="n">n</span><span class="w">  </span><span class="c1">-- 使用上面定义的 n</span>
<span class="w">              </span><span class="kr">in</span><span class="w"> </span><span class="o">...</span><span class="n">g</span><span class="o">...</span>
</pre></div>
</div>
<p>这个版本是完全惰性版本，因为我们将 <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">..</span></code> 移出了 <code class="docutils literal notranslate"><span class="pre">g</span></code> 函数体内的 lambda 表达式。通过利用惰性求值并避免对 <code class="docutils literal notranslate"><span class="pre">n</span></code> 的重复、无效计算，这个版本效率更高。在 <code class="docutils literal notranslate"><span class="pre">g</span></code> 的第一次迭代中，<code class="docutils literal notranslate"><span class="pre">n</span></code> 将是一个惰性求值的表达式（thunk），但在后续的每次迭代中，<code class="docutils literal notranslate"><span class="pre">n</span></code> 都将被评估为一个值，从而节省了时间和空间。</p>
</section>
</section>
<section id="canonical-domain-modeling">
<span id="id23"></span><h2><span class="section-number">1.2.5. </span>糟糕的领域建模<a class="headerlink" href="#canonical-domain-modeling" title="Link to this heading">¶</a></h2>
<section id="id24">
<h3><span class="section-number">1.2.5.1. </span>定义<a class="headerlink" href="#id24" title="Link to this heading">¶</a></h3>
<p>Poor domain modeling is a catch all phrase for constructing a program that has a
high impedance to the problem domain. The problem domain is the abstract domain
that dictates the computation that the program must do, the logical sequence of
steps it must take and the invariants it must uphold. The program domain is the
implementation, it is the code that is tasked with performing the computation
and upholding the invariants in the problem domain. This is a one-to-many
relationship; for any given problem domain there are many possible
implementations.</p>
<p>For example, imagine our task is to implement a program that sorts some data. We
can list the concepts, invariants and properties this problem domain specifies:
the domain has the concepts of a datum; which is a single unit of information, a
partial order on that data; there are many sequences of data, but for a given
set of data only two sequences have the property sorted, a datum must have an
ordinal property; or else we would not be able to sort, and the sorted
invariant; that defines what the property sorted means: for a sort from low to
high, a given datum that is less than another datum must precede the greater
datum in the output sequence. Note that every possible implementation must
somehow represent and abide by these ideas for the program to be considered
correct and for the implementation to be considered an implementation at all.</p>
<p>Therefore poor domain modeling occurs when the implementation makes it difficult
to express the computation, properties and invariants required by the problem
domain. If this is the case then we say there is a high impedance between the
problem domain and the program domain. Obviously this is problem specific and we
cannot provide a canonical example, instead we’ll provide a set of guidelines to
describe when you know you have high impedance and how to fix it.</p>
</section>
<section id="id25">
<h3><span class="section-number">1.2.5.2. </span>如何知道程序是否存在糟糕的领域建模<a class="headerlink" href="#id25" title="Link to this heading">¶</a></h3>
<p>不幸的是，这更多的是一种艺术而非科学，需要主观的判断。Haskell 中典型的场景是所有 instance 的实现做了很多不必要的工作。</p>
<section id="data-list">
<h4><span class="section-number">1.2.5.2.1. </span>过度使用 Data.List<a class="headerlink" href="#data-list" title="Link to this heading">¶</a></h4>
<p>下列 <code class="docutils literal notranslate"><span class="pre">Data.List</span></code> 中的函数，可以对任意无序列表进行处理，或是需要遍历整个列表。</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">length</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">splitAt</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">takeWhile</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dropWhile</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elem</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">notElem</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">find</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">filter</span></code></p></li>
<li><p>…其他的索引</p></li>
</ol>
<p>请记住，Haskell 中的列表是流；不将它们视为流不仅会在问题领域和你的程序之间产生阻抗，还会降低运行时性能（并且很容易创建一个平方时间复杂度的程序）。然而，包含少量元素的小型临时列表是可以的，因为它们的构建和遍历所需的时间比更复杂的数据结构要少。</p>
</section>
<section id="id26">
<h4><span class="section-number">1.2.5.2.2. </span>函数组合的不易<a class="headerlink" href="#id26" title="Link to this heading">¶</a></h4>
<p>组合性和可组合性是代码最有价值的属性之一。它是模块化的关键，也是代码重用的关键，能够创建更易于测试、更易于理解且通常更紧凑的代码。当你的程序领域中的函数不易组合时，你会经常发现自己在不断地打包、解包和重新打包领域元素，只为了完成任何事情。你将被迫深入到程序领域对象的*实现*中，以便在问题领域中表达意义，而不是通过函数表达这种意义。</p>
<p>当程序领域缺乏可组合性时，函数会变得过于庞大，并且过于关注实现细节；这就是在实现中表现出的高阻抗。</p>
<div class="admonition-todo admonition" id="id28">
<p class="admonition-title">Todo</p>
<p>下一个例子可以参考 <a class="reference external" href="https://github.com/input-output-hk/hs-opt-handbook.github.io/issues/20">#20</a></p>
</div>
</section>
<section id="id29">
<h4><span class="section-number">1.2.5.2.3. </span>问题领域的不变量难以表达<a class="headerlink" href="#id29" title="Link to this heading">¶</a></h4>
<p>这通常表现为使用了多余的 guard。许多函数采取如下形式：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | 一个关于 Foo 的示例函数，通过根据多个谓词测试 Foo</span>
<span class="nf">myFunction</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bar</span>
<span class="nf">myFunction</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">predicate0</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="kr">do</span><span class="w"> </span><span class="n">something</span><span class="w"> </span><span class="o">...</span>
<span class="w">               </span><span class="o">|</span><span class="w"> </span><span class="n">predicate1</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="kr">do</span><span class="w"> </span><span class="n">another</span><span class="w"> </span><span class="n">thing</span><span class="o">...</span>
<span class="w">               </span><span class="o">|</span><span class="w"> </span><span class="o">...</span>
<span class="w">               </span><span class="o">|</span><span class="w"> </span><span class="n">predicateN</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="kr">do</span><span class="w"> </span><span class="kt">N</span><span class="w"> </span><span class="n">thing</span><span class="o">...</span>
</pre></div>
</div>
<p>当这种模式在代码库中变得无处不在时，就会成为一个问题。当程序中的许多函数使用守卫时，程序将遭受冗余检查和糟糕的分支预测。例如：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | another function on Foo, this function doesn&#39;t learn much about Foo</span>
<span class="c1">-- because it only tests Foo against one predicate.</span>
<span class="nf">myOtherFunction</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Baz</span>
<span class="nf">myOtherFunction</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">predicate1</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="kr">do</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">another</span><span class="w"> </span><span class="n">thing</span><span class="o">...</span>
<span class="w">                    </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getFoo</span><span class="w">          </span><span class="c1">-- we get a Foo</span>
<span class="w">          </span><span class="n">myFunction</span><span class="w"> </span><span class="n">foo</span><span class="w">         </span><span class="c1">-- we learn a lot about Foo</span>
<span class="w">          </span><span class="n">myOtherFunction</span><span class="w"> </span><span class="n">foo</span><span class="w">    </span><span class="c1">-- nothing we&#39;ve learned is propagated forward</span>
<span class="w">                                 </span><span class="c1">--  from myFunction to myOtherFunction, and so</span>
<span class="w">                                 </span><span class="c1">--  we redundantly check predicate1 on foo.</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="references">
<h2><span class="section-number">1.2.6. </span>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id30" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://wiki.haskell.org/Inlining_and_Specialisation">https://wiki.haskell.org/Inlining_and_Specialisation</a></p>
</aside>
<aside class="footnote brackets" id="id31" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.sciencedirect.com/science/article/pii/030439759090147A?via%3Dihub">https://www.sciencedirect.com/science/article/pii/030439759090147A?via%3Dihub</a></p>
</aside>
<aside class="footnote brackets" id="id32" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/deforestation-short-cut.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/deforestation-short-cut.pdf</a></p>
</aside>
<aside class="footnote brackets" id="id33" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">4</a><span class="fn-bracket">]</span></span>
<p>This code adapted from Johan Tibell slides on Haskell <a class="reference external" href="https://www.slideshare.net/tibbe/highperformance-haskell">optimization</a>.</p>
</aside>
<aside class="footnote brackets" id="id34" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id21">5</a><span class="fn-bracket">]</span></span>
<p>This code adapted from <span id="id35">Peyton Jones and Santos [<a class="reference internal" href="../../../contents.html#id5" title="Simon Peyton Jones and Andre Santos. A transformation-based optimiser for haskell. Science of Computer Programming, October 1997. URL: https://www.microsoft.com/en-us/research/publication/a-transformation-based-optimiser-for-haskell/.">2</a>]</span> Section 7.</p>
</aside>
</aside>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
  <li class="prev">
    <a href="how_to_use.html"
       title="previous chapter">← <span class="section-number">1.1. </span>如何使用本书</a>
  </li>
  <li class="next">
    <a href="../../glossary.html"
       title="next chapter">Glossary →</a>
  </li>
</ul><div class="footer" role="contentinfo">
      &#169; Copyright 2022-1980, Jeffrey Young (doyougnu).
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.2.6 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>